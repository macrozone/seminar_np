\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\date{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  _____   ____  _____                                          %
% |_   _| /  __||  __ \    Institute of Computitional Physics   %
%   | |  |  /   | |__) |   Zuercher Hochschule Winterthur       %
%   | |  | (    |  ___/    (University of Applied Sciences)     %
%  _| |_ |  \__ | |        8401 Winterthur, Switzerland         %
% |_____| \____||_|                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Project     : LaTeX doc Vorlage für Windows ProTeXt mit TexMakerX
% Title       : 
% File        : header.tex Rev. 00
% Date        : 23.4.12
% Author      : Remo Ritzmann
% Feedback bitte an Email: remo.ritzmann@pfunzle.ch
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass[twoside,10pt,parskip=half,ngerman]{scrreprt}

%***********************************************************************
% include some libs
%***********************************************************************
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{fancyhdr}
\usepackage{rotating}
\usepackage{titlesec}
\usepackage{mathptmx}
 \usepackage{helvet}
\usepackage[scaled]{uarial}
\renewcommand*\familydefault{\sfdefault} %% Only if the base font of the document is to be sans serif
\usepackage[T1]{fontenc}
\usepackage{ngerman}
\usepackage{textcomp}
\usepackage[squaren]{SIunits}
\usepackage{graphicx}
\usepackage{url}
\usepackage{geometry}
\usepackage[absolute]{textpos}
\usepackage{makeidx}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{pdfpages}
\usepackage{tabularx}
\usepackage{lmodern}
\usepackage{longtable}
\usepackage{array}
\usepackage{float}
\usepackage{scrhack}
\usepackage{wallpaper} %\ThisTileWallPaper{}
\usepackage[super,square]{natbib} %für BibTeX Literaturverzeichnis




%***********************************************************************
% various styles
%***********************************************************************	

%create index
\makeindex

%define pagestyle
\pagestyle{fancy}

%use sans-serif font 
%\renewcommand{\familydefault}{\sfdefault}

%define page margin
\geometry{a4paper, top=30mm, left=30mm, right=30mm, bottom=30mm,headsep=10mm,footskip=10mm}

%textpos parameter
\setlength{\TPHorizModule}{30mm}
\setlength{\TPVertModule}{\TPHorizModule}
\textblockorigin{10mm}{10mm} % start everything near the top-left corner
\setlength{\parindent}{0pt}

%horizontal lines for titlepage 
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

%reference to source items inlc source number
\newcommand{\srcref}[1]{\nameref{src:#1} \cite{#1}}

%header / footer 
\renewcommand{\headrulewidth}{0.3pt}
\renewcommand{\footrulewidth}{0.3pt}

\renewcommand{\arraystretch}{1.5}

\fancyhead[LO,RE]{} %clear headings for contents 
\fancyhead[RO,LE]{\nouppercase{\rightmark}} %right odd pages and left even pages
\fancyhead[LO,RE]{\MakeUppercase{\leftmark}} %left odd pages and right even pages
\fancyfoot[LE,RO]{\thepage} %page numbering
\fancyfoot[C]{} %clear centered page numbering 

%define some colors
\definecolor{gray}{rgb}{0.95,0.95,0.95}
\definecolor{darkgray}{rgb}{0.4,0.4,0.4}
%listing colors
\definecolor{lgray}{RGB}{250,250,250}
\definecolor{lgreen}{RGB}{63,127,95}
\definecolor{lred}{RGB}{127,0,85}
\definecolor{lblue}{RGB}{42,0,255}

%***********************************************************************
% listing
%***********************************************************************

\lstset{		
		basicstyle=\small\ttfamily,
		frame=single,
		numbers=left,	
		numberstyle=\tiny,
		%firstnumber=auto,
		numberblanklines=true,
		captionpos=b,
		extendedchars=true,
		float=ht,
		showtabs=false,
		tabsize=2,
		showspaces=false,
		showstringspaces=false,
		breaklines=true,
		%prebreak=\Righttorque,
		backgroundcolor=\color{lgray},
		keywordstyle=\color{lred}\bfseries, 
		commentstyle=\color{lgreen}\ttfamily,
%		morekeywords={printstr, printhexln},
		stringstyle=\color{lblue},
		xleftmargin=0.5cm,
		xrightmargin=0.5cm
}

\lstloadlanguages{C++}


\makeatletter
\newcommand{\customlabel}[2]{%
   \protected@write \@auxout {}{\string \newlabel {#1}{{#2}{\thepage}{#2}{#1}{}} }%
   \hypertarget{#1}{#2}
}
\makeatother
%\lstdefinelanguage{xc}{
%     keywords={printstr, printhexln, attributes, class, classend, do, empty, endif, endwhile, fail, function, functionend, if, implements, in, inherit, inout, not, of, operations, out, return, set, then, types, while, use},
%     keywordstyle=\color{lred}\bfseries,
%     ndkeywords={},
%     ndkeywordstyle=\color{yellow}\bfseries,
%     identifierstyle=\color{black},
%     sensitive=false,
%     comment=[l]{//},
%     commentstyle=\color{lgreen}\ttfamily,
%     string=[l]{"},
%     stringstyle=\color{lblue}\ttfamily
%  }




\begin{document}

{
\hypersetup{linkcolor=black}
\setcounter{tocdepth}{}
\tableofcontents
}
<p></p>
<h1 id="begriffe"><span class="header-section-number">1</span> Begriffe</h1>
<h2 id="online-probleme"><span class="header-section-number">1.1</span> Online-Probleme</h2>
<p>Online-Probleme sind Probleme, bei denen die Eingabe zu Beginn nicht vollständig bekannt sind, sondern laufend hinzukommen. Sie sind eine wichtige Klasse von Problemen und treten beispielsweise bei der Planung von (CPU-)-Jobs / Scheduling auf.</p>
<p>Definition: Online Maximierungs-Problem</p>
<p>Online-Probleme bestehen aus Menge von Eingaben <span class="math">ℐ</span>, Eingabe <span class="math"><em>I</em> ∈ ℐ</span> mit <span class="math"><em>I</em> = (<em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>n</em></sub>)</span>, sowie einer <span class="math">$\mathit(gain)$</span>-Funktion. Zu jeder Eingabe kann eine Menge von Ausgaben mit jeweils O=(y_1, ..., y_n) zugeordnert werden. <span class="math"><em>g</em><em>a</em><em>i</em><em>n</em><em>(</em><em>I</em><em>,</em> <em>O</em><em>)</em></span> ordnet dabei zu jeder Eingabe und passender Ausgabe eine positive, reelle Zahl zu. Für jede Eingabe I nennen wir diejenige Lösung O eine <em>optimale Lösung von I</em>, für welche <span class="math"><em>g</em><em>a</em><em>i</em><em>n</em><em>(</em><em>I</em><em>,</em> <em>O</em><em>)</em></span> maximal ist. Wir schreiben diese als </p>
<p>Definition: Online-Algorithmus mit <em>Advice</em></p>
<h2 id="advice-komplexität"><span class="header-section-number">1.2</span> Advice-Komplexität</h2>
<p></p>
<h1 id="das-einfache-online-rucksackproblem"><span class="header-section-number">2</span> Das einfache Online-Rucksackproblem</h1>
<h2 id="greedy-ansatz"><span class="header-section-number">2.1</span> Greedy-Ansatz</h2>
<p><span class="math">1 − <em>β</em></span></p>
<h2 id="untere-grenze-für-optimalität"><span class="header-section-number">2.2</span> Untere Grenze für Optimalität</h2>
<p>n-1 advice-bits</p>
<h2 id="aone---2-competitive"><span class="header-section-number">2.3</span> AONE - 2-competitive</h2>
<h2 id="grenzen-für-logn-1-adice-bits"><span class="header-section-number">2.4</span> Grenzen für log(n-1) Adice bits</h2>
<p><span class="math">2 − <em>ϵ</em></span></p>
<h2 id="slog"><span class="header-section-number">2.5</span> SLOG</h2>
<h1 id="vergleich-mit-randomisierten-algorithmen"><span class="header-section-number">3</span> Vergleich mit randomisierten Algorithmen</h1>
<h2 id="random-bit-rone---4-competive"><span class="header-section-number">3.1</span> 1 Random bit: RONE - 4-competive</h2>
<h2 id="random-bit-rone---2-competive"><span class="header-section-number">3.2</span> 1 Random bit: RONE' - 2-competive</h2>
<h2 id="mehr-random-bits-keine-verbesserung"><span class="header-section-number">3.3</span> Mehr Random-bits: keine Verbesserung</h2>
<p></p>
<h1 id="ausblick"><span class="header-section-number">4</span> Ausblick</h1>
<h2 id="rucksackproblem-mit-überfüllen"><span class="header-section-number">4.1</span> Rucksackproblem mit Überfüllen</h2>
<h2 id="das-gewichtete-online-rucksackproblem"><span class="header-section-number">4.2</span> Das gewichtete Online-Rucksackproblem</h2>
<h1 id="todo"><span class="header-section-number">5</span> todo:</h1>
<ul>
<li>graph von bits / n, sprung-marken</li>
</ul>
<h1 id="online-knapsack-problem"><span class="header-section-number">6</span> Online-Knapsack-Problem</h1>
<h2 id="the-knapsack-problem"><span class="header-section-number">6.1</span> The knapsack-problem</h2>
<p>Consider a knapsack with a certain capacity of weight (or volume) and a set of items, each with a value and a weight.</p>
<p>Which subset of these items would you put into the knapsack to get the maximum possible total value respecting the capacity of the knapsack?</p>
<p>This question is the so called knapsack-problem.</p>
<h3 id="the-simple-knapsack-problem"><span class="header-section-number">6.1.1</span> The simple-knapsack-problem</h3>
<p>In this paper, we only consider the so called <em>simple-knapsack-problem</em> where the value of one item is the same as its weight and where the knapsack has always a capacity of 1.</p>
<p>We call the total value of all items in the knapsack as the <em>gain</em>.</p>
<p>Let's define such a knapsack:</p>
<pre><code>Knapsack = class 
    constructor: -&gt;
        @size = 1
        @dep = new Tracker.Dependency
        @reset()
    
    fits: (item) -&gt; 
        @gain() + item.value &lt;= @size

    addItem: (item) -&gt;
        if @fits item
            @items.push item
            @dep.changed()

    gain: -&gt; 
        roundValue _.reduce @getItems(), ((total, item) -&gt; total+item.value), 0
    
    getItems: -&gt;
        @dep.depend()
        @items

    reset: -&gt;
        @items = []
        @dep.changed()</code></pre>
<h2 id="the-online-knapsack-problem"><span class="header-section-number">6.2</span> The Online-Knapsack-Problem</h2>
<p>In the former <em>offline</em>-knapsack-problem, we know all items that we want to put in the knapsack. In the <em>online</em>-version of this problem, we do not know every item, but get the items one by one. We therefore have to decide after every item, whether we put the item in the knapsack or not.</p>
<p>We create a base-algorithm for that:</p>
<pre><code>Algorithm = class
    constructor: -&gt;
        @act = new ReactiveVar
        @_knapsack = new Knapsack
    knapsack: -&gt; @_knapsack

    handle: (item) -&gt;
        if @decide item 
            @_knapsack.addItem item 
            return yes
        else
            return no
    decide: (item) -&gt;
        # implement me and return yes or no

    reset: -&gt;
        @_knapsack.reset()
        @act.set null
    doAct: (like) -&gt; @act.set like
    acts: (like) -&gt; @act.get() is like</code></pre>
<p>What maximum gain would can we achieve and how would an online-algorithm perform in comparison with an optimal offline-algorithm, which would know every item?</p>
<p>Let's try out.</p>
<pre><code>experiments = []</code></pre>
<p>Lets start with the greedy aproach. Here, we just take every item we get, if it fits:</p>
<pre><code>decideGreedy = (item) -&gt; if @knapsack().fits item then yes else no</code></pre>
<p>and we define an algorithm with it:</p>
<pre><code>Greedy = class extends Algorithm
    decide: decideGreedy</code></pre>
<p>The gain of this algorithm is at least 1-β, where β is the size of the item with the highest value (weight). The proof is simple: if we get this item with value β, the gain is certainly higher than β. If this item does not fit anymore in the knapsack, we will have at least 1-β gain.</p>
<p>Lets do some experiments with it to verify this:</p>
<pre><code>experiments.push
    name: -&gt; &quot;Greedy G&quot;
    description: -&gt; &quot;G archieves at least 1-beta, where beta is here #{@beta}&quot;
    beta: 0.5
    Algorithm: Greedy

experiments.push
    name: -&gt; &quot;Greedy G&quot;
    description: -&gt; &quot;G archieves at least 1-beta, where beta is here #{@beta}&quot;
    beta: 0.2
    Algorithm: Greedy

experiments.push
    name: -&gt; &quot;Greedy G&quot;
    description: -&gt; &quot;G archieves at least 1-beta, where beta is here #{@beta}&quot;
    beta: 0.8
    Algorithm: Greedy</code></pre>
<h2 id="online-algorithm-with-advice"><span class="header-section-number">6.3</span> Online-Algorithm with advice</h2>
<pre><code>experimentsWithAdvice = []</code></pre>
<p>Imaging you had an oracle, that would know all items that will come. How many bits of information from this oracle would you need to get an optimal solution? And for a given amount of these advice bits, how good would your algorithm perform?</p>
<p>We define such an algorithm as <em>online algorithm with advice</em>.</p>
<p>Let <em>I</em> be an input of such an online algorithm <em>A</em> and Φ an (infinite) sequence of bits (1 or 0), called *advice bits. The online-algorithm can read a finit prefix of this sequence.</p>
<p>The gain of this Algorithm is <em>gain(A^Φ(I))</em>.</p>
<p>If we have <em>n</em> items in a solution and have read <em>s(n)</em> advice-bits while computing this solution in the algorithm we call <em>s(n)</em> the <em>advice-complexity</em>.</p>
<p>If we compare the <em>gain</em> of this algorithm with the gain of an optimal offline algorithm OPT, we can define its <em>competitiveness</em>:</p>
<p><em>gain(A^Φ(I))</em> &gt;= 1/c * gain(OPT(I)) - α*</p>
<p>where α is a constant and we call this algorithm <em>c-competitive</em>. If <em>α = 0</em>, <em>A</em> is <em>strictly c-competitive</em>.</p>
<p>Let's implement a base class for such an algorithm:</p>
<pre><code>AlgorithmWithAdvice = class extends Algorithm
    constructor: -&gt;
        @adviceBits = new ReactiveVar
        super
    askOracle: (items) -&gt;
        if @oracle?
            @adviceBits.set @oracle items
    oracle: (items) -&gt;
        # implement me and return an array of advice-bits
    readAdviceBit: (index) -&gt;
        @adviceBits.get()?[index]
    reset: -&gt;
        super
        @adviceBits.set null</code></pre>
<h2 id="optimal-online-algorithm-with-advice"><span class="header-section-number">6.4</span> Optimal online algorithm with advice</h2>
<p>Let's go back to the first question with the first question: how many advice bits do we have to read to get an optimal solution?</p>
<p>Consider an algorithm with an oracle, that would give us a bit for every item coming with</p>
<ul>
<li>value 1 if the item is part of the solution</li>
<li>value 0 if the item does not belong to the solution</li>
</ul>
<p>Obviously, we need n bits of advice for that, or n-1, because for the last item, we can assume that it is part of the optimal solution.</p>
<p>We now define an algorithm for that.</p>
<p>Note: The items are prepared in a way, that some are allready marked as solution. That makes it easier to define the oracle here:</p>
<pre><code>TotalInformation = class extends AlgorithmWithAdvice
    oracle: (items) -&gt;
        bits = []
        for item in items
            bits[item.index] = if item.isPartOfSolution then 1 else 0
        # we do not need the last bit
        bits.pop()
        return bits</code></pre>
<p>The decision is now easy. If we have a bit (yes / no), we use it:</p>
<pre><code>    decide: (item) -&gt;
        adviceBit = @readAdviceBit item.index
        if adviceBit? then adviceBit else yes</code></pre>
<p>Lets do an experiment with it:</p>
<pre><code>experimentsWithAdvice.push
    name: -&gt; &quot;Total Information&quot;
    beta: 0.4
    Algorithm: TotalInformation</code></pre>
<p>As <span class="citation">(<span class="citeproc-not-found" data-reference-id="onlineKnapsack"><strong>???</strong></span>)</span> states, any algorithm for the online simple knapsack problem needs at least n-1 bits to be optimal.</p>
<h2 id="advice-bit"><span class="header-section-number">6.5</span> 1 Advice bit</h2>
<p>What's the best gain if we had only 1 advice bit?</p>
<p>Let's do an experiment where we have an oracle that gives us one bit:</p>
<pre><code>AONE = class extends AlgorithmWithAdvice
    oracle: (allItems) -&gt; [ _.some allItems, (item) -&gt; item.value &gt; 0.5 ] # array with one bit</code></pre>
<p>The bit tells us:</p>
<ul>
<li>1: There exists an item with a size &gt; 0.5</li>
<li>0: There is no such item</li>
</ul>
<p>If the bit is 0, the algorithm acts greedy (like before). If the bit is 1, the algorithm waits until the item with size &gt; 0.5 appears and will start acting greedyly:</p>
<pre><code>    decide: (item)-&gt; 
        adviceBit = @readAdviceBit item.index
        if adviceBit? # existance
            if adviceBit is false then @doAct &quot;greedy&quot; else @doAct &quot;wait&quot;
        if @acts &quot;greedy&quot; then decideGreedy.call @, item else @wait item
        
    wait: (item) -&gt;
        if item?.value &gt; 0.5
            @doAct &quot;greedy&quot;
            decideGreedy.call @, item
        else
            no</code></pre>
<p>This algorithm is 2-competitive:</p>
<ul>
<li>If there is no item with weight &gt; 1/2, the gain is at least 1/2 as we have already seen in the greedy approach.</li>
<li>On the other hand if such an item exists, the algorithm will wait for it and put it in, so it will get a gain of at least 1/2</li>
</ul>
<p>We do an experiment with a max size of one item of 0.55 to verify this:</p>
<pre><code>experimentsWithAdvice.push
    name: &quot;AONE - with one advice bit&quot;
    description: &quot;AONE is 2-competitive&quot;
    beta: 0.55
    Algorithm: AONE</code></pre>
<p>This one single bit gives us an competitive-ratio of 2, but what happens if we increase the amount of bits? Can we achieve a better ratio?</p>
<p>Unfortunatly, more advice bits does not give us a better competitive-ratio, at least for a sub-logarithmic amount <em>s(n)</em> of advice bits. Figure  shows the number of bits compared with the achieved competitive-ratio.</p>
<p>There is a second jump at <em>SLOG</em>-bits, where competitiveness is 1+ε.</p>
<div class="figure">
<img src="competitivenessChart.png" alt="Number of bits VS competitiveness" />
<p class="caption">Number of bits VS competitiveness</p>
</div>
<h2 id="randomized-online-algorithms"><span class="header-section-number">6.6</span> Randomized Online-Algorithms</h2>
<pre><code>randomExperiments = []</code></pre>
<p>Obviously in real online-problems, we do not have an omniscient oracle. But we can use the idea of the oracle and just guess the advice bits <em>randomly</em>.</p>
<p>We can then estimate the competitiveness of this <em>randomized online-algorithm</em>.</p>
<h3 id="rone---aone-with-random-advice-bit"><span class="header-section-number">6.6.1</span> RONE - AONE with random advice bit</h3>
<p>Let's start with AONE from the previous experiment, but guess the adviceBit randomly:</p>
<pre><code>RONE = class extends AONE
    oracle: -&gt;
        [Math.random() &lt; 0.5]</code></pre>
<p>If we guess wrong, we might get a lower gain then 0.5 or even 0, if the adviceBit is 1 and we have no item with size &gt; 0.5.</p>
<p>So while we have a 2-competivenes in AONE, we have here a 4-competitivenes in expectation (in 50% of the cases, we are wrong).</p>
<pre><code>randomExperiments.push
    name: &quot;RONE - one random bit&quot;
    description: &quot;Is 4-competitive in expectation&quot;
    beta: 0.55
    Algorithm: RONE</code></pre>
<h3 id="competivenes-with-1-advice-bit"><span class="header-section-number">6.6.2</span> 2-competivenes with 1 advice bit</h3>
<p>The competitive-ratio of 4 is somewhat obvious, but suprisingly, we can also achieve a ratio of 2 with only 1 advice bit.</p>
<p>Consider an algorithm that choses randomly between two algorithms A1 and A2. A1 is the greedy approach we already know:</p>
<pre><code>A1 = Greedy</code></pre>
<p>A2 internaly simulates A1 at the beginning:</p>
<pre><code>A2 = class extends Algorithm
    reset: -&gt;
        super
        @a1 = new A1
        @doAct &quot;simulateA1&quot;</code></pre>
<p>To decide wheter it will use the item or not, it first offers it to the simulated A1-Algorithm. As soon as A1 won't take the item anymore (A1' knapsack is full), A2 starts to act greedyly:</p>
<pre><code>    decide: (item) -&gt;
        if @acts &quot;simulateA1&quot;
            if @a1.handle item
                return no
            else
                @doAct &quot;greedy&quot;
                return @decide item
        else if @acts &quot;greedy&quot;
            return decideGreedy.call @, item</code></pre>
<p>We now compose an algorithm &quot;RONE2&quot;, that choses randomly between A1 and A2:</p>
<pre><code>RONE2 = class extends AlgorithmWithAdvice
    constructor: -&gt;
        @a1 = new A1
        @a2 = new A2
        super
    oracle: -&gt; [Math.random() &lt; 0.5]
    reset: -&gt;
        super
        @a1.reset()
        @a2.reset()
    knapsack: -&gt; @algorithm().knapsack()
    # handle decides and put the item in the knapsack
    handle: (item) -&gt;
        adviceBit = @readAdviceBit item.index
        if adviceBit? # existance of the first bit
            if adviceBit then @doAct &quot;A1&quot; else @doAct &quot;A2&quot;
        @algorithm().handle item
    algorithm: -&gt;
        if @acts &quot;A1&quot; then @a1 else @a2</code></pre>
<p>We do now an experiment with it:</p>
<pre><code>randomExperiments.push
    name: &quot;RONE2 - one random bit&quot;
    description: &quot;Is 2-competitive in expectation&quot;
    beta: 0.55
    Algorithm: RONE2</code></pre>
<p>To show that this algorithm is 2-competitive in expectation, we consider two cases:</p>
<ul>
<li>If the sum of all items is less than the knapsack's capacity, A1 is optimal, while A2 gains 0. Because we chose randomly between the two algorithm, we have a 50% chance to get an optimal gain (or to get 0).</li>
<li>If the sum is greater, the total gain of A1 and A2 is at least 1. Because we chose randomly between the two, we get a 0.5 gain in expecation.</li>
</ul>
<p>Considering both cases, we get a gain of 0.5 in expecation, so the algorithm is 2-competitive.</p>
<h1 id="setup"><span class="header-section-number">7</span> Setup</h1>
<p>The following code sets the experiments up. First, define some constants:</p>
<pre><code>Constants = 
    SCALE: 300

roundValue = (value) -&gt; Math.round(value*100)/100</code></pre>
<p>First, the creation of items:</p>
<pre><code>createItems = ({beta, maxSize}) -&gt;
    items = []
    beta ?= 0.5
    maxSize ?= 1
    totalSize = 0
    
    loop 
        randomValue = -&gt; roundValue Math.random()*beta
        value = randomValue()
        if totalSize+value &lt; maxSize
            totalSize += value
            items.push {value, isPartOfSolution: yes}
        else
            # add one that fits exactly
            items.push 
                value: roundValue maxSize - totalSize
                isPartOfSolution: yes
            # add the one that does not fit
            items.push {value}
            break

    items = _.shuffle items
    for item, index in items
        item.index = index
    # we later pop the elements out (from the end) because it is faster. So we reverse here:
    return items.reverse() </code></pre>
<p>Add the experiments to the template</p>
<pre><code>Template.experiments.helpers
    experiments: -&gt; experiments
    experimentsWithAdvice: -&gt; experimentsWithAdvice
    randomExperiments: -&gt; randomExperiments

Template.Experiment.onCreated -&gt;
    
    @items = []
    
    @currentItem = new ReactiveVar
    @numberOfItems = new ReactiveVar
    @algorithm = new @data.Algorithm
    @gainHistory = 
        history: []
        dep: new Tracker.Dependency
        add: (gainValue) -&gt;
            if gainValue &gt; 0
                @worstGain = Math.min @worstGain ? gainValue, gainValue
            @bestGain = Math.max @bestGain ? gainValue, gainValue
            @history.push gainValue
            @dep.changed()
        size: -&gt;
            @dep.depend()
            @history.length
        worst: -&gt;
            @dep.depend()
            @worstGain
        best: -&gt;
            @dep.depend()
            @bestGain
        competitiveCount: -&gt;
            @dep.depend()
            _.countBy @history, (value) -&gt;
                
                if value is 1
                    &quot;1-competitive&quot;
                else if 0.5 &lt;= value &lt; 1
                    &quot;2-competitive&quot;
                else if 0.25 &lt;= value &lt; 0.5
                    &quot;4-competitive&quot;
                else
                    &quot;non-competitive&quot;
                
        
        competitivePercentage: (cGroup)-&gt;
            @dep.depend()
            if @history.length &gt; 0
                roundValue 100 * @competitiveCount()[cGroup] / @history.length
        avg: -&gt;
            @dep.depend()
            if @history.length &gt; 0
                roundValue (_.reduce @history, (total, value) -&gt; total+value)/@history.length
        reset: -&gt;
            @history = []
            @bestGain = null
            @worstGain = null
            @dep.changed()
    resetExperiment = =&gt;
        
        @items = createItems beta: @data.beta
        @algorithm.reset?()
        @algorithm.askOracle? @items
        @numberOfItems.set @items.length
        @currentItem.set @items.pop()

    do reset = =&gt;
        @gainHistory.reset()
        resetExperiment()
    
    @ticker = new Ticker 
        reset: =&gt;
            reset()

        turn: =&gt;
            # 1. step: fetch new item
            # 2. step: put it in knapsack
            
            item = @currentItem.get()
            if item?
                @algorithm.handle item
                @currentItem.set @items.pop()
            else
                # no more items
                
                @gainHistory.add @algorithm.knapsack().gain()
                resetExperiment()
                


Template.Experiment.helpers 
    adviceBits: -&gt; Template.instance().algorithm.adviceBits?.get()
    act: -&gt; Template.instance().algorithm.act.get()
    knapsack: -&gt; Template.instance().algorithm.knapsack()
    ticker: -&gt; Template.instance().ticker
    currentItem: -&gt;Template.instance().currentItem?.get()
    gainHistory: -&gt; Template.instance().gainHistory
    numberOfItems: -&gt; Template.instance().numberOfItems.get()
    willMatch: -&gt; 
        ctx = Template.instance()
        ctx.currentItem?.get()?.value + ctx.algorithm.knapsack().gain() &lt;= ctx.algorithm.knapsack().size

Template.Knapsack.helpers
    totalWidth: -&gt;
        @size * Constants.SCALE + 2
    items: -&gt; 
        @getItems()
Template.KnapsackItem.helpers
    width:  -&gt; 
        @value * Constants.SCALE
    color: -&gt;
        hue = @value*360
        &quot;hsl(#{hue}, 73%, 69%)&quot;
Template.competitivenessChart.helpers
    chartObject: -&gt; 
        legend: enabled: false
        title: text: &quot;&quot;
        yAxis: 
            title: text: &quot;competitiveness&quot;
            tickPositioner: -&gt; [1,1.1,1.9,2,3]
            labels: 
                formatter: -&gt;
                    switch @value
                        when 1 then &quot;optimal&quot;
                        when 1.1 then &quot;1+ε-competitive&quot;
                        when 1.9 then &quot;2-ε-competitive&quot;
                        when 2 then &quot;2-competitive&quot;
                        when 3 then &quot;non-competitive&quot;
                        
        xAxis:
            title: text: &quot;bits&quot;
            tickPositioner: -&gt;  [0,1,7,77,127]  
            labels: 
                rotation: -45
                formatter: -&gt;
                    switch @value
                        #when 0 then &quot;0 bits&quot;
                        when 1 then &quot;1 bit&quot;
                        when 7 then &quot;log(n-1) bits&quot;
                        when 77 then &quot;SLOG bits (*)&quot;
                        when 127 then &quot;n-1 bits&quot;
        series: [
            type: &quot;area&quot;
            step: &quot;left&quot;
            data: [
                (x: 0, y: 3, name: &quot;non-competitive&quot;)
                (x: 1, y: 2, name: &quot;2-competitive&quot;)
                (x: 7, y: 1.9, name: &quot;2-ε-competitive&quot;)
                (x: 77, y: 1.1, name: &quot;1+ε-competitive&quot;)
                (x: 127, y: 1, name: &quot;optimal&quot;)
            ]
        ]

Template.TickerGui.helpers
    counter: -&gt; @ticker.getCounter()

Template.TickerGui.events
    &#39;click .btn-step&#39;: -&gt; @ticker.step()
    &#39;click .btn-play&#39;: -&gt; 
        @ticker.setTimeout 100
        @ticker.play()
    &#39;click .btn-play-fast&#39;: -&gt;
        @ticker.setTimeout 0
        @ticker.play()
    &#39;click .btn-stop&#39;: -&gt; @ticker.stop()
    &#39;click .btn-reset&#39;: -&gt; @ticker.reset()</code></pre>
<div class="references">

</div>

\end{document}
